<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>White Void Gallery</title>
    <link rel="preconnect" href="https://esm.sh">
    <link rel="preconnect" href="https://www.gstatic.com">
    <link rel="preconnect" href="https://firebasestorage.googleapis.com">
    <style>
        body { margin: 0; overflow: hidden; background-color: #ffffff; font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; touch-action: none; -webkit-user-select: none; user-select: none; }
        #intro-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #ffffff; z-index: 2000; pointer-events: none; display: flex; justify-content: center; align-items: center; opacity: 1; }
        #loading-msg { font-size: 10px; color: #aaa; letter-spacing: 3px; font-weight: 500; animation: pulse 2s infinite; }
        @keyframes pulse { 0% { opacity: 0.3; } 50% { opacity: 1; } 100% { opacity: 0.3; } }
        #click-capture { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 998; display: none; cursor: pointer; background: rgba(0,0,0,0); }
        #instruction { position: absolute; bottom: 30px; width: 100%; text-align: center; color: #bbb; font-size: 11px; z-index: 999; pointer-events: none; opacity: 0; transition: opacity 1.0s; letter-spacing: 1px; text-transform: uppercase; }
        #joystick-zone { position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); width: 160px; height: 160px; z-index: 1500; display: none; }
        .joystick-base { width: 100%; height: 100%; background: transparent; border: none; position: relative; }
        .joystick-knob { width: 40px; height: 40px; background: rgba(0, 0, 0, 0.2); border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; transition: transform 0.1s; }
        .joystick-active .joystick-knob { background: rgba(0, 0, 0, 0.4); transform: translate(-50%, -50%) scale(1.1); }
        @media (max-width: 768px) { #instruction { display: none; } #joystick-zone { display: block; } }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.160.0",
                "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/",
                "gsap": "https://esm.sh/gsap@3.12.5"
            }
        }
    </script>
</head>
<body>
    <div id="intro-overlay"><div id="loading-msg">ENTERING...</div></div>
    <div id="click-capture"></div>
    <div id="instruction">Click to Start | WASD to Move</div>
    <div id="joystick-zone"><div class="joystick-base"><div class="joystick-knob" id="joystick-knob"></div></div></div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import gsap from 'gsap';
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getFirestore, collection, getDocs, query, where } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyAl_IaEOIKzrnulRN6j0pn0uN_aJFdAPOc",
            authDomain: "online-white-box.firebaseapp.com",
            projectId: "online-white-box",
            storageBucket: "online-white-box.firebasestorage.app",
            messagingSenderId: "227799896378",
            appId: "1:227799896378:web:94e416ee99d0e720e18003",
            measurementId: "G-G2ZWQZ8W8F"
        };

        let app, db;
        try { app = initializeApp(firebaseConfig); db = getFirestore(app); } catch(e) { console.error(e); }

        let camera, scene, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        let sculptureWrapper;
        let labelMesh; 
        let colliderRadius = 0.1; 
        const targetPosition = new THREE.Vector3(0, 0, -6);
        const DESKTOP_CAM_POS = new THREE.Vector3(0, 1.7, 8); 
        const MOBILE_CAM_POS = new THREE.Vector3(0, 1.7, 14);
        
        let isModelLoaded = false;
        let isIntroFinished = false; // === 新增：交互锁状态 ===
        
        const clickCaptureDiv = document.getElementById('click-capture');
        const introOverlayDiv = document.getElementById('intro-overlay');
        const instructionText = document.getElementById('instruction');

        // 移动端控制变量
        let joystickVector = { x: 0, y: 0 }; 
        let lookTouchId = null;
        let lastLookX = 0; let lastLookY = 0;
        let lastTapTime = 0; let lastTapPos = { x: 0, y: 0 };
        
        // === 新增：丝滑阻尼变量 ===
        let targetRotationY = 0;
        let targetRotationX = 0;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
            
            if (window.innerWidth < window.innerHeight) { camera.position.copy(MOBILE_CAM_POS); } 
            else { camera.position.copy(DESKTOP_CAM_POS); }
            camera.lookAt(targetPosition.x, targetPosition.y + 1.5, targetPosition.z);
            camera.rotation.order = 'YXZ'; 
            
            // 初始化目标角度为当前角度
            targetRotationY = camera.rotation.y;
            targetRotationX = camera.rotation.x;

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0xeeeeee, 1.2); hemiLight.position.set(0, 20, 0); scene.add(hemiLight);
            const keyLight = new THREE.DirectionalLight(0xffffff, 3.5); 
            keyLight.position.set(0, 15, 0); keyLight.castShadow = true;
            keyLight.shadow.mapSize.set(2048, 2048); keyLight.shadow.bias = -0.0001; keyLight.shadow.radius = 10; 
            const d = 15; keyLight.shadow.camera.left = -d; keyLight.shadow.camera.right = d; keyLight.shadow.camera.top = d; keyLight.shadow.camera.bottom = -d; 
            scene.add(keyLight);
            const fillLight = new THREE.DirectionalLight(0xffeedd, 1.5); fillLight.position.set(-8, 5, 8); scene.add(fillLight);
            const topLight = new THREE.DirectionalLight(0xffffff, 0.8); topLight.position.set(0, 10, -6); scene.add(topLight);

            const pmremGenerator = new THREE.PMREMGenerator( new THREE.WebGLRenderer() );
            pmremGenerator.compileEquirectangularShader();
            scene.environment = pmremGenerator.fromScene(new THREE.Scene()).texture;

            const planeGeometry = new THREE.PlaneGeometry(200, 200);
            const shadowMaterial = new THREE.ShadowMaterial({ color: 0x000000, opacity: 0.12 });
            const floor = new THREE.Mesh(planeGeometry, shadowMaterial);
            floor.rotation.x = -Math.PI / 2; floor.position.y = 0; floor.receiveShadow = true; scene.add(floor);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace; 
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.5;
            document.body.appendChild(renderer.domElement);

            controls = new PointerLockControls(camera, document.body);
            
            setupControlsEvents(); setupKeyControls(); setupTouchControls(); setupDoubleClickReset(); 
            window.addEventListener('resize', onWindowResize);

            if(db) checkPinAndLoad(); 
            else loadDefaultSculpture();
        }

        async function checkPinAndLoad() {
            try {
                const pinQuery = query(collection(db, "model_library"), where("pinned", "==", true));
                const pinSnapshot = await getDocs(pinQuery);
                if (!pinSnapshot.empty) {
                    const pinDoc = pinSnapshot.docs[0].data();
                    loadModelFromUrl(pinDoc.url, pinDoc.name);
                    return;
                }
                const q = query(collection(db, "model_library"), where("active", "==", true));
                const querySnapshot = await getDocs(q);
                let models = [];
                querySnapshot.forEach((doc) => { models.push({ id: doc.id, ...doc.data() }); });
                if (models.length === 0) { loadDefaultSculpture(); return; }
                const lastModelId = localStorage.getItem('last_model_id');
                if (models.length > 1 && lastModelId) { models = models.filter(m => m.id !== lastModelId); }
                const index = Math.floor(Math.random() * models.length);
                const selected = models[index];
                localStorage.setItem('last_model_id', selected.id);
                loadModelFromUrl(selected.url, selected.name);
            } catch (error) { console.error(error); loadDefaultSculpture(); }
        }

        function loadModelFromUrl(url, name) {
            const loader = new GLTFLoader();
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
            loader.setDRACOLoader(dracoLoader);
            loader.load(url, (gltf) => {
                processAndPlaceModel(gltf.scene, name);
                revealScene();
            }, undefined, (err) => { revealScene(); });
        }

        function loadDefaultSculpture() {
            const group = new THREE.Group();
            const material = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.2, metalness: 0.8 });
            const geo = new THREE.TorusKnotGeometry(0.8, 0.25, 128, 64);
            const mesh = new THREE.Mesh(geo, material); mesh.castShadow = true; mesh.receiveShadow = true; group.add(mesh);
            processAndPlaceModel(group, "Default Sculpture");
            revealScene();
        }

        function generateSystematicName(seed) {
            let hash = 0;
            if (!seed || seed.length === 0) return "NULL · 000 · Ø";
            for (let i = 0; i < seed.length; i++) { hash = ((hash << 5) - hash) + seed.charCodeAt(i); hash |= 0; }
            hash = Math.abs(hash);
            const prefixes = ["OBJ", "ARCH", "SYS", "NODE", "DATA", "CORE", "FLUX", "VOID", "UNIT", "SPEC", "FORM"];
            const symbols = ["α", "β", "γ", "δ", "ε", "ζ", "η", "θ", "ι", "κ", "λ", "μ", "Σ", "Ω", "Ø", "Δ"];
            const pIndex = hash % prefixes.length;
            const sIndex = (hash >> 3) % symbols.length;
            const charCode = String.fromCharCode(65 + (hash % 26)); 
            const num = (hash % 999).toString().padStart(3, '0'); 
            return `${prefixes[pIndex]} · ${charCode}${num} · ${symbols[sIndex]}`;
        }

        function createMuseumLabel(modelName, sizeInfo) {
            if (labelMesh) { scene.remove(labelMesh); labelMesh = null; }
            const systematicName = generateSystematicName(modelName);
            const mockYear = Math.floor(Math.random() * (2025 - 2000 + 1)) + 2000;
            const materials = ["Bronze, Patina", "Polished Steel", "Marble", "Digital Polymer", "Mixed Media", "Resin", "Ceramic"];
            const randMat = materials[Math.floor(Math.random() * materials.length)];
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512; 
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#f9f9f9'; ctx.fillRect(0, 0, 512, 512);
            ctx.textAlign = 'left';
            ctx.font = 'bold 50px Helvetica, Arial'; ctx.fillStyle = '#1a1a1a'; ctx.fillText(systematicName, 40, 80);
            ctx.font = '36px Helvetica, Arial'; ctx.fillStyle = '#333333'; ctx.fillText(mockYear, 40, 140);
            ctx.font = '30px Helvetica, Arial'; ctx.fillStyle = '#333333'; ctx.fillText(randMat, 40, 260);
            ctx.font = '24px Helvetica, Arial'; ctx.fillStyle = '#333333'; ctx.fillText(sizeInfo, 40, 310);
            ctx.font = '20px Helvetica, Arial'; ctx.fillStyle = '#555555'; ctx.fillText("Courtesy of the Digital Archive", 40, 460);
            ctx.strokeStyle = '#bbbbbb'; ctx.lineWidth = 10; ctx.strokeRect(0, 0, 512, 512);
            const texture = new THREE.CanvasTexture(canvas);
            const labelGeo = new THREE.BoxGeometry(0.3, 0.015, 0.3); 
            const labelMat = new THREE.MeshStandardMaterial({ map: texture, color: 0xffffff, roughness: 0.8 });
            const mesh = new THREE.Mesh(labelGeo, labelMat);
            mesh.castShadow = true; mesh.receiveShadow = true;
            return mesh;
        }

        function getSolidHeight(model, boxHeight) {
            const yCoords = [];
            model.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    const pos = child.geometry.attributes.position;
                    const v = new THREE.Vector3();
                    for (let i = 0; i < pos.count; i += 5) {
                        v.fromBufferAttribute(pos, i);
                        v.applyMatrix4(child.matrix);
                        yCoords.push(v.y);
                    }
                }
            });
            if (yCoords.length === 0) return boxHeight; 
            yCoords.sort((a, b) => a - b);
            const trimStart = Math.floor(yCoords.length * 0.02); 
            const trimEnd = Math.floor(yCoords.length * 0.98);
            const minY = yCoords[trimStart] || yCoords[0];
            const maxY = yCoords[trimEnd] || yCoords[yCoords.length - 1];
            let solidH = maxY - minY;
            if (solidH < boxHeight * 0.2) return boxHeight;
            return solidH;
        }

        function processAndPlaceModel(rawModel, rawName) {
            if (sculptureWrapper) scene.remove(sculptureWrapper);
            if (labelMesh) scene.remove(labelMesh);
            rawModel.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true; child.receiveShadow = true;
                    if (child.material && child.material.color) {
                         if(child.material.color.r < 0.1 && child.material.color.g < 0.1 && child.material.color.b < 0.1) child.material.color.setHex(0xaaaaaa);
                         child.material.needsUpdate = true;
                    }
                }
            });
            rawModel.position.set(0,0,0); rawModel.scale.set(1,1,1); rawModel.rotation.set(0,0,0); rawModel.updateMatrixWorld(true);
            const initialBox = new THREE.Box3().setFromObject(rawModel);
            const initialSize = initialBox.getSize(new THREE.Vector3());
            const solidHeight = getSolidHeight(rawModel, initialSize.y);
            const targetHeight = 3.5;
            const scaleFactor = targetHeight / solidHeight;
            rawModel.scale.setScalar(scaleFactor); rawModel.updateMatrixWorld(true);
            const newBox = new THREE.Box3().setFromObject(rawModel);
            const newCenter = newBox.getCenter(new THREE.Vector3());
            const finalSize = newBox.getSize(new THREE.Vector3());
            sculptureWrapper = new THREE.Group(); scene.add(sculptureWrapper);
            rawModel.position.x = -newCenter.x; rawModel.position.z = -newCenter.z; rawModel.position.y = -newBox.min.y; 
            sculptureWrapper.add(rawModel);
            sculptureWrapper.position.copy(targetPosition); sculptureWrapper.rotation.y = 0; 
            const formattedSize = `${(finalSize.x).toFixed(1)}m x ${(finalSize.y).toFixed(1)}m x ${(finalSize.z).toFixed(1)}m`;
            labelMesh = createMuseumLabel(rawName || "Untitled", formattedSize);
            const wrapperZ = targetPosition.z; const labelZ = wrapperZ + (finalSize.z / 2) + 1.0; 
            labelMesh.position.set(0, 0.01, labelZ); labelMesh.rotation.x = 0; scene.add(labelMesh);
            colliderRadius = Math.max(finalSize.x, finalSize.z) / 2 + 0.1; 
            isModelLoaded = true;
        }

        function revealScene() {
            setTimeout(() => {
                gsap.to(introOverlayDiv, { opacity: 0, duration: 2.0, ease: "power2.inOut", 
                    onComplete: () => { 
                        introOverlayDiv.style.display = 'none'; 
                        clickCaptureDiv.style.display = 'block'; 
                        instructionText.style.opacity = '1';
                        isIntroFinished = true; // === 关键：动画结束后才解锁交互 ===
                    }
                });
            }, 100);
        }

        function resetCamera(duration = 1.5, ease = "power2.inOut") {
             if (!isModelLoaded || !isIntroFinished) return;
             const destPos = (window.innerWidth < window.innerHeight) ? MOBILE_CAM_POS : DESKTOP_CAM_POS;
             gsap.to(camera.position, { x: destPos.x, y: destPos.y, z: destPos.z, duration: duration, ease: ease });
             const tempCam = camera.clone();
             tempCam.position.copy(destPos);
             tempCam.lookAt(targetPosition.x, targetPosition.y + 1.5, targetPosition.z);
             gsap.to(camera.quaternion, { x: tempCam.quaternion.x, y: tempCam.quaternion.y, z: tempCam.quaternion.z, w: tempCam.quaternion.w, duration: duration, ease: ease });
             // 同步丝滑阻尼的目标值，防止复位后跳变
             const euler = new THREE.Euler(0,0,0, 'YXZ');
             euler.setFromQuaternion(tempCam.quaternion);
             targetRotationY = euler.y;
             targetRotationX = euler.x;
        }

        function setupDoubleClickReset() {
            window.addEventListener('dblclick', () => { resetCamera(0.15, "expo.out"); });
            document.addEventListener('touchstart', (e) => {
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTapTime;
                const touch = e.changedTouches[0];
                const dist = Math.sqrt(Math.pow(touch.clientX - lastTapPos.x, 2) + Math.pow(touch.clientY - lastTapPos.y, 2));
                if (tapLength < 250 && tapLength > 0 && dist < 30) { e.preventDefault(); resetCamera(0.5, "power2.inOut"); } 
                else { lastTapPos = { x: touch.clientX, y: touch.clientY }; lastTapTime = currentTime; }
            }, { passive: false });
        }

        function setupTouchControls() {
            const joystickZone = document.getElementById('joystick-zone');
            const joystickKnob = document.getElementById('joystick-knob');
            const zoneRect = joystickZone.getBoundingClientRect();
            const center = { x: zoneRect.width / 2, y: zoneRect.height / 2 };
            const maxRadius = (zoneRect.width / 2) - 20;
            let joystickTouchId = null;

            joystickZone.addEventListener('touchstart', (e) => {
                if (!isIntroFinished) return; // 锁
                e.preventDefault();
                const touch = e.changedTouches[0];
                joystickTouchId = touch.identifier;
                joystickZone.classList.add('joystick-active');
                updateJoystick(touch);
            }, {passive: false});

            joystickZone.addEventListener('touchmove', (e) => {
                if (!isIntroFinished) return;
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystickTouchId) {
                        updateJoystick(e.changedTouches[i]);
                        break;
                    }
                }
            }, {passive: false});

            const endJoystick = (e) => {
                 for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystickTouchId) {
                        joystickTouchId = null;
                        joystickVector = { x: 0, y: 0 };
                        joystickZone.classList.remove('joystick-active');
                        gsap.to(joystickKnob, { left: '50%', top: '50%', duration: 0.2 });
                        break;
                    }
                }
            };
            joystickZone.addEventListener('touchend', endJoystick);
            joystickZone.addEventListener('touchcancel', endJoystick);

            function updateJoystick(touch) {
                const rect = joystickZone.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                let dx = x - center.x; let dy = y - center.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                if (distance > maxRadius) { const angle = Math.atan2(dy, dx); dx = Math.cos(angle) * maxRadius; dy = Math.sin(angle) * maxRadius; }
                joystickKnob.style.left = (center.x + dx) + 'px'; joystickKnob.style.top = (center.y + dy) + 'px';
                joystickVector.x = dx / maxRadius; joystickVector.y = dy / maxRadius; 
            }

            document.addEventListener('touchstart', (e) => {
                if (!isIntroFinished) return; // 锁
                if (e.target.closest('#joystick-zone')) return;
                const touch = e.changedTouches[0];
                lookTouchId = touch.identifier;
                lastLookX = touch.clientX; lastLookY = touch.clientY;
            }, {passive: false});

            document.addEventListener('touchmove', (e) => {
                if (!isIntroFinished) return;
                let touch = null;
                for(let i=0; i<e.changedTouches.length; i++) { if(e.changedTouches[i].identifier === lookTouchId) { touch = e.changedTouches[i]; break; } }
                if (!touch) return;
                const deltaX = touch.clientX - lastLookX; const deltaY = touch.clientY - lastLookY;
                lastLookX = touch.clientX; lastLookY = touch.clientY;
                
                // === 修改：丝滑阻尼逻辑 ===
                const sensitivity = 0.004; // 灵敏度
                targetRotationY -= deltaX * sensitivity;
                targetRotationX -= deltaY * sensitivity;
                targetRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetRotationX));
                
            }, {passive: false});

            document.addEventListener('touchend', (e) => { for(let i=0; i<e.changedTouches.length; i++) { if(e.changedTouches[i].identifier === lookTouchId) { lookTouchId = null; break; } } });
        }

        function setupControlsEvents() { 
            controls.addEventListener('lock', () => { clickCaptureDiv.style.display = 'none'; instructionText.style.opacity = '0'; }); 
            controls.addEventListener('unlock', () => { if (isModelLoaded) { clickCaptureDiv.style.display = 'block'; instructionText.style.opacity = '1'; } }); 
            if (!('ontouchstart' in window)) { clickCaptureDiv.addEventListener('click', () => { if(isIntroFinished) controls.lock(); }); } else { clickCaptureDiv.style.display = 'none'; }
        }
        
        function setupKeyControls() { const onKeyDown = (e) => { if(!isIntroFinished) return; switch (e.code) { case 'ArrowUp': case 'KeyW': moveForward = true; break; case 'ArrowLeft': case 'KeyA': moveLeft = true; break; case 'ArrowDown': case 'KeyS': moveBackward = true; break; case 'ArrowRight': case 'KeyD': moveRight = true; break; } }; const onKeyUp = (e) => { switch (e.code) { case 'ArrowUp': case 'KeyW': moveForward = false; break; case 'ArrowLeft': case 'KeyA': moveLeft = false; break; case 'ArrowDown': case 'KeyS': moveBackward = false; break; case 'ArrowRight': case 'KeyD': moveRight = false; break; } }; document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp); }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function checkCollision() { if (!sculptureWrapper) return; const playerPos = new THREE.Vector2(camera.position.x, camera.position.z); const objectPos = new THREE.Vector2(sculptureWrapper.position.x, sculptureWrapper.position.z); const distance = playerPos.distanceTo(objectPos); if (distance < colliderRadius) { const pushDir = playerPos.sub(objectPos).normalize(); const newPos = objectPos.add(pushDir.multiplyScalar(colliderRadius)); camera.position.x = newPos.x; camera.position.z = newPos.y; } }
        
        function animate() { 
            requestAnimationFrame(animate); 
            const time = performance.now(); 
            const delta = (time - prevTime) / 1000;
            velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta; 
            direction.z = Number(moveForward) - Number(moveBackward); direction.x = Number(moveRight) - Number(moveLeft); direction.normalize(); 
            
            if (isIntroFinished) { // 只在进入后处理移动逻辑
                if (moveForward || moveBackward) velocity.z -= direction.z * 80.0 * delta; if (moveLeft || moveRight) velocity.x -= direction.x * 80.0 * delta; 
                if (joystickVector.x !== 0 || joystickVector.y !== 0) { velocity.z -= -joystickVector.y * 80.0 * delta; velocity.x -= joystickVector.x * 80.0 * delta; }
                
                if (controls.isLocked) { // 桌面模式
                    controls.moveRight(-velocity.x * delta); controls.moveForward(-velocity.z * delta); 
                } else { // 移动端/非锁定模式
                    const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir); camDir.y = 0; camDir.normalize(); 
                    const camRight = new THREE.Vector3(); camRight.crossVectors(camDir, new THREE.Vector3(0, 1, 0)).normalize(); 
                    camera.position.addScaledVector(camDir, -velocity.z * delta); camera.position.addScaledVector(camRight, -velocity.x * delta);
                    
                    // === 新增：丝滑插值应用 ===
                    // 只有在非PointerLock模式下（即触摸模式），我们才手动插值旋转
                    // 使用 Lerp 逼近目标值，系数 0.1 决定了“阻尼感”
                    camera.rotation.y += (targetRotationY - camera.rotation.y) * 0.1;
                    camera.rotation.x += (targetRotationX - camera.rotation.x) * 0.1;
                }
                checkCollision(); 
            }
            
            prevTime = time; 
            renderer.render(scene, camera); 
        }
    </script>
</body>
</html>