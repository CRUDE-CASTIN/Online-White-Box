<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>White Void Gallery</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #ffffff; font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; }
        #intro-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #ffffff; z-index: 2000; pointer-events: none; opacity: 1; }
        #click-capture { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 998; display: none; cursor: pointer; background: rgba(0,0,0,0); }
        #instruction { position: absolute; bottom: 30px; width: 100%; text-align: center; color: #bbb; font-size: 11px; z-index: 999; pointer-events: none; opacity: 0; transition: opacity 1.0s; letter-spacing: 1px; text-transform: uppercase; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
            }
        }
    </script>
</head>
<body>
    <div id="intro-overlay"></div>
    <div id="click-capture"></div>
    <div id="instruction">Click to Start | WASD to Move</div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import gsap from 'gsap';
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getFirestore, collection, getDocs, query, where } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        // === Firebase Config ===
        const firebaseConfig = {
            apiKey: "AIzaSyAl_IaEOIKzrnulRN6j0pn0uN_aJFdAPOc",
            authDomain: "online-white-box.firebaseapp.com",
            projectId: "online-white-box",
            storageBucket: "online-white-box.firebasestorage.app",
            messagingSenderId: "227799896378",
            appId: "1:227799896378:web:94e416ee99d0e720e18003",
            measurementId: "G-G2ZWQZ8W8F"
        };

        let app, db;
        try { app = initializeApp(firebaseConfig); db = getFirestore(app); } catch(e) { console.error(e); }

        let camera, scene, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        let sculptureWrapper;
        let labelMesh; 
        let colliderRadius = 2.0;
        const targetPosition = new THREE.Vector3(0, 0, -6);
        let isModelLoaded = false;
        
        const clickCaptureDiv = document.getElementById('click-capture');
        const introOverlayDiv = document.getElementById('intro-overlay');
        const instructionText = document.getElementById('instruction');

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.7, 4); 

            // === 修改点：光照位置 ===
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0xeeeeee, 1.2); 
            hemiLight.position.set(0, 20, 0); 
            scene.add(hemiLight);

            const keyLight = new THREE.DirectionalLight(0xffffff, 3.5); 
            // 位置设置：X=0(正中), Y=15(正上方高处), Z=0(位于相机和雕塑之间)
            // 雕塑在 Z=-6，所以 Z=0 是在雕塑的前方。光线从上方+前方射下。
            keyLight.position.set(0, 15, 0); 
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.set(4096, 4096); 
            keyLight.shadow.bias = -0.0001; 
            keyLight.shadow.radius = 2;
            const d = 15; 
            keyLight.shadow.camera.left = -d; keyLight.shadow.camera.right = d; 
            keyLight.shadow.camera.top = d; keyLight.shadow.camera.bottom = -d; 
            scene.add(keyLight);

            const fillLight = new THREE.DirectionalLight(0xffeedd, 1.5); 
            fillLight.position.set(-8, 5, 8); 
            scene.add(fillLight);
            
            // 额外的顶光增加神圣感
            const topLight = new THREE.DirectionalLight(0xffffff, 0.8); 
            topLight.position.set(0, 10, -6); // 正对着雕塑头顶
            scene.add(topLight);

            const pmremGenerator = new THREE.PMREMGenerator( new THREE.WebGLRenderer() );
            pmremGenerator.compileEquirectangularShader();
            scene.environment = pmremGenerator.fromScene(new THREE.Scene()).texture;

            const planeGeometry = new THREE.PlaneGeometry(200, 200);
            const shadowMaterial = new THREE.ShadowMaterial({ color: 0x000000, opacity: 0.15 });
            const floor = new THREE.Mesh(planeGeometry, shadowMaterial);
            floor.rotation.x = -Math.PI / 2; floor.position.y = 0; floor.receiveShadow = true; scene.add(floor);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace; 
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.5;
            document.body.appendChild(renderer.domElement);

            controls = new PointerLockControls(camera, document.body);
            setupControlsEvents(); setupKeyControls(); window.addEventListener('resize', onWindowResize);

            if(db) loadRandomModel(); 
            else loadDefaultSculpture();
        }

        async function loadRandomModel() {
            try {
                const q = query(collection(db, "model_library"), where("active", "==", true));
                const querySnapshot = await getDocs(q);
                const models = [];
                querySnapshot.forEach((doc) => models.push(doc.data()));

                if (models.length === 0) { loadDefaultSculpture(); return; }
                
                const index = Math.floor(Math.random() * models.length);
                console.log(`Loading random model: ${models[index].name}`);
                loadModelFromUrl(models[index].url, models[index].name);

            } catch (error) { console.error(error); loadDefaultSculpture(); }
        }

        function loadModelFromUrl(url, name) {
            const loader = new GLTFLoader();
            loader.load(url, (gltf) => {
                processAndPlaceModel(gltf.scene, name);
                revealScene();
            }, undefined, (err) => { console.error(err); revealScene(); });
        }

        function loadDefaultSculpture() {
            const group = new THREE.Group();
            const material = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.2, metalness: 0.8 });
            const geo = new THREE.TorusKnotGeometry(0.8, 0.25, 128, 64);
            const mesh = new THREE.Mesh(geo, material); mesh.castShadow = true; mesh.receiveShadow = true; group.add(mesh);
            processAndPlaceModel(group, "Default Sculpture");
            revealScene();
        }

        function createMuseumLabel(modelName, sizeInfo) {
            if (labelMesh) { scene.remove(labelMesh); labelMesh = null; }
            const mockYear = Math.floor(Math.random() * (2025 - 2000 + 1)) + 2000;
            const materials = ["Bronze, Patina", "Polished Steel", "Marble", "Digital Polymer", "Mixed Media"];
            const randMat = materials[Math.floor(Math.random() * materials.length)];
            const cleanName = modelName.replace(".glb", "").replace(/^\d+_/, "").replace(/_/g, " ");

            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512; 
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#f9f9f9'; ctx.fillRect(0, 0, 512, 512);
            ctx.fillStyle = '#111'; ctx.textAlign = 'left';
            
            ctx.font = 'bold 50px Helvetica, Arial'; ctx.fillText(cleanName, 40, 80);
            ctx.font = '36px Helvetica, Arial'; ctx.fillStyle = '#666'; ctx.fillText(mockYear, 40, 140);
            ctx.font = '30px Helvetica, Arial'; ctx.fillStyle = '#333'; ctx.fillText(randMat, 40, 260);
            ctx.font = '24px Helvetica, Arial'; ctx.fillStyle = '#555'; ctx.fillText(sizeInfo, 40, 310);
            ctx.font = '20px Helvetica, Arial'; ctx.fillStyle = '#999'; ctx.fillText("Courtesy of the Digital Archive", 40, 460);
            ctx.strokeStyle = '#ddd'; ctx.lineWidth = 8; ctx.strokeRect(0, 0, 512, 512);

            const texture = new THREE.CanvasTexture(canvas);
            const labelGeo = new THREE.BoxGeometry(0.3, 0.015, 0.3); 
            const labelMat = new THREE.MeshStandardMaterial({ map: texture, color: 0xffffff, roughness: 0.8 });
            const mesh = new THREE.Mesh(labelGeo, labelMat);
            mesh.castShadow = true; mesh.receiveShadow = true;
            return mesh;
        }

        // === 智能实心高度算法 ===
        function getSolidHeight(model) {
            const yCoords = [];
            model.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    const pos = child.geometry.attributes.position;
                    const v = new THREE.Vector3();
                    for (let i = 0; i < pos.count; i += 5) {
                        v.fromBufferAttribute(pos, i);
                        v.applyMatrix4(child.matrix);
                        yCoords.push(v.y);
                    }
                }
            });
            if (yCoords.length === 0) return 1.0; 
            yCoords.sort((a, b) => a - b);
            const trimStart = Math.floor(yCoords.length * 0.02); 
            const trimEnd = Math.floor(yCoords.length * 0.98);
            const minY = yCoords[trimStart] || yCoords[0];
            const maxY = yCoords[trimEnd] || yCoords[yCoords.length - 1];
            let height = maxY - minY;
            if (height < 0.1) {
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                height = size.y;
            }
            return height;
        }

        function processAndPlaceModel(rawModel, rawName) {
            if (sculptureWrapper) scene.remove(sculptureWrapper);
            if (labelMesh) scene.remove(labelMesh);

            rawModel.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true; child.receiveShadow = true;
                    if (child.material && child.material.color) {
                         if(child.material.color.r < 0.1 && child.material.color.g < 0.1 && child.material.color.b < 0.1) child.material.color.setHex(0xaaaaaa);
                         child.material.needsUpdate = true;
                    }
                }
            });

            // 1. 归一化
            rawModel.position.set(0,0,0);
            rawModel.scale.set(1,1,1);
            rawModel.rotation.set(0,0,0);
            rawModel.updateMatrixWorld(true);

            // 2. 智能计算“实心高度”
            const solidHeight = getSolidHeight(rawModel);
            
            // 3. 计算缩放比例：目标高度 3.5m
            const targetHeight = 3.5;
            const scaleFactor = targetHeight / solidHeight;
            
            rawModel.scale.setScalar(scaleFactor);
            rawModel.updateMatrixWorld(true);

            // 4. 计算最终包围盒
            const newBox = new THREE.Box3().setFromObject(rawModel);
            const newCenter = newBox.getCenter(new THREE.Vector3());
            const finalSize = newBox.getSize(new THREE.Vector3());

            sculptureWrapper = new THREE.Group(); scene.add(sculptureWrapper);
            
            // 5. 居中并落地
            rawModel.position.x = -newCenter.x;
            rawModel.position.z = -newCenter.z;
            rawModel.position.y = -newBox.min.y; 
            sculptureWrapper.add(rawModel);

            sculptureWrapper.position.copy(targetPosition);
            
            // === 修改点：移除旋转，保持 0 ===
            sculptureWrapper.rotation.y = 0; 

            const formattedSize = `${(finalSize.x).toFixed(1)}m x ${(finalSize.y).toFixed(1)}m x ${(finalSize.z).toFixed(1)}m`;
            labelMesh = createMuseumLabel(rawName || "Untitled", formattedSize);
            
            const wrapperZ = targetPosition.z;
            const labelZ = wrapperZ + (finalSize.z / 2) + 1.0; 
            
            labelMesh.position.set(0, 0.01, labelZ); 
            labelMesh.rotation.x = 0; 
            scene.add(labelMesh);

            colliderRadius = Math.max(finalSize.x, finalSize.z) / 2 + 0.4; 
            
            isModelLoaded = true;
        }

        function revealScene() {
            setTimeout(() => {
                gsap.to(introOverlayDiv, { opacity: 0, duration: 2.5, ease: "power2.inOut", onComplete: () => { 
                    introOverlayDiv.style.display = 'none'; 
                    clickCaptureDiv.style.display = 'block'; 
                    instructionText.style.opacity = '1'; 
                }});
            }, 100);
        }

        function setupControlsEvents() { controls.addEventListener('lock', () => { clickCaptureDiv.style.display = 'none'; instructionText.style.opacity = '0'; }); controls.addEventListener('unlock', () => { if (isModelLoaded) { clickCaptureDiv.style.display = 'block'; instructionText.style.opacity = '1'; } }); clickCaptureDiv.addEventListener('click', () => controls.lock()); }
        function setupKeyControls() { const onKeyDown = (e) => { switch (e.code) { case 'ArrowUp': case 'KeyW': moveForward = true; break; case 'ArrowLeft': case 'KeyA': moveLeft = true; break; case 'ArrowDown': case 'KeyS': moveBackward = true; break; case 'ArrowRight': case 'KeyD': moveRight = true; break; } }; const onKeyUp = (e) => { switch (e.code) { case 'ArrowUp': case 'KeyW': moveForward = false; break; case 'ArrowLeft': case 'KeyA': moveLeft = false; break; case 'ArrowDown': case 'KeyS': moveBackward = false; break; case 'ArrowRight': case 'KeyD': moveRight = false; break; } }; document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp); }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function checkCollision() { if (!sculptureWrapper) return; const playerPos = new THREE.Vector2(camera.position.x, camera.position.z); const objectPos = new THREE.Vector2(sculptureWrapper.position.x, sculptureWrapper.position.z); const distance = playerPos.distanceTo(objectPos); if (distance < colliderRadius) { const pushDir = playerPos.sub(objectPos).normalize(); const newPos = objectPos.add(pushDir.multiplyScalar(colliderRadius)); camera.position.x = newPos.x; camera.position.z = newPos.y; } }
        function animate() { requestAnimationFrame(animate); const time = performance.now(); if (controls.isLocked === true) { const delta = (time - prevTime) / 1000; velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta; direction.z = Number(moveForward) - Number(moveBackward); direction.x = Number(moveRight) - Number(moveLeft); direction.normalize(); if (moveForward || moveBackward) velocity.z -= direction.z * 80.0 * delta; if (moveLeft || moveRight) velocity.x -= direction.x * 80.0 * delta; controls.moveRight(-velocity.x * delta); controls.moveForward(-velocity.z * delta); checkCollision(); } prevTime = time; renderer.render(scene, camera); }
    </script>
</body>
</html>