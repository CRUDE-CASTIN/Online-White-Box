<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MONOLOGUE / 24</title>
    
    <link rel="preconnect" href="https://esm.sh">
    <link rel="preconnect" href="https://cdn.jsdelivr.net"> 

    <style>
        body { margin: 0; overflow: hidden; background-color: #ffffff; font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; touch-action: none; -webkit-user-select: none; user-select: none; }
        
        #intro-overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background-color: #ffffff; 
            z-index: 2000; 
            pointer-events: none; 
            display: flex; justify-content: center; align-items: center;
            opacity: 1; 
        }

        #loading-msg {
            font-size: 10px; color: #aaa; letter-spacing: 3px; font-weight: 500;
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { opacity: 0.3; } 50% { opacity: 1; } 100% { opacity: 0.3; } }

        #click-capture { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 998; display: none; cursor: pointer; background: rgba(0,0,0,0); }
        
        #realtime-clock {
            position: absolute; bottom: 50px; width: 100%; text-align: center;
            color: #333; font-size: 12px; font-weight: 400;
            font-family: 'Courier New', Courier, monospace; 
            z-index: 999; pointer-events: none;
            opacity: 0; transition: opacity 1.0s;
            letter-spacing: 6px; transform: scaleX(1.1); font-variant-numeric: tabular-nums; 
        }

        #instruction { 
            position: absolute; bottom: 20px; width: 100%; text-align: center; 
            color: #ccc; 
            font-size: 10px; 
            z-index: 999; pointer-events: none; 
            opacity: 0; transition: opacity 1.0s; letter-spacing: 1px; text-transform: uppercase;
        }

        #brand-logo {
            position: absolute; top: 30px; left: 30px;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-weight: 700; font-size: 12px; 
            color: #333333; 
            letter-spacing: 2px; z-index: 999; pointer-events: none;
            opacity: 0; transition: opacity 2.0s ease-in;
        }

        .mobile-text { display: none; }
        .desktop-text { display: inline; }

        #joystick-zone {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 160px; height: 160px; 
            z-index: 1500; display: none;
        }
        .joystick-base { width: 100%; height: 100%; background: transparent; border: none; position: relative; }
        .joystick-knob {
            width: 40px; height: 40px; 
            background: rgba(0, 0, 0, 0.2); 
            border-radius: 50%;
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            transition: transform 0.1s;
        }
        .joystick-active .joystick-knob { background: rgba(0, 0, 0, 0.4); transform: translate(-50%, -50%) scale(1.1); }

        @media (max-width: 768px) {
            #joystick-zone { display: block; }
            #instruction { font-size: 8px; letter-spacing: 0.5px; width: 96%; left: 2%; white-space: nowrap; }
            .desktop-text { display: none; }
            .mobile-text { display: inline; }
            #brand-logo { top: 20px; left: 20px; font-size: 10px; } 
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.160.0",
                "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/",
                "gsap": "https://esm.sh/gsap@3.12.5",
                "firebase/app": "https://esm.sh/firebase@10.7.1/app",
                "firebase/firestore": "https://esm.sh/firebase@10.7.1/firestore"
            }
        }
    </script>
</head>
<body>
    <div id="intro-overlay"><div id="loading-msg">ENTERING...</div></div>
    <div id="click-capture"></div>
    
    <div id="brand-logo">MONOLOGUE / 24</div>
    <div id="realtime-clock">0000-00-00 00:00:00</div>
    
    <div id="instruction">
        <span class="desktop-text">Click to Start | WASD to Move | Scroll to Zoom | Double Click to Reset</span>
        <span class="mobile-text">Tap to Start | Joystick to Move | Pinch to Zoom | Double Tap to Reset</span>
    </div>
    
    <div id="joystick-zone"><div class="joystick-base"><div class="joystick-knob" id="joystick-knob"></div></div></div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import gsap from 'gsap';
        
        // 修改：从 esm.sh 导入 Firebase，国内加载几率更高
        import { initializeApp } from "firebase/app";
        import { getFirestore, collection, getDocs, query, where } from "firebase/firestore";

        const firebaseConfig = {
            apiKey: "AIzaSyAl_IaEOIKzrnulRN6j0pn0uN_aJFdAPOc",
            authDomain: "online-white-box.firebaseapp.com",
            projectId: "online-white-box",
            storageBucket: "online-white-box.firebasestorage.app",
            messagingSenderId: "227799896378",
            appId: "1:227799896378:web:94e416ee99d0e720e18003",
            measurementId: "G-G2ZWQZ8W8F"
        };

        let app, db;
        // 尝试初始化 Firebase，如果失败（网络问题）则忽略，依靠 timeout 兜底
        try { app = initializeApp(firebaseConfig); db = getFirestore(app); } catch(e) { console.warn("Firebase init failed (Offline mode?)", e); }

        let camera, scene, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        let sculptureWrapper;
        let labelMesh; 
        let colliderRadius = 0.1; 
        const targetPosition = new THREE.Vector3(0, 0, -6);
        const DESKTOP_CAM_POS = new THREE.Vector3(0, 1.7, 8); 
        const MOBILE_CAM_POS = new THREE.Vector3(0, 1.7, 14);
        
        let isModelLoaded = false;
        let isIntroFinished = false; 
        let isResetting = false; 
        
        const clickCaptureDiv = document.getElementById('click-capture');
        const introOverlayDiv = document.getElementById('intro-overlay');
        const instructionText = document.getElementById('instruction');
        const clockDiv = document.getElementById('realtime-clock');
        const brandLogo = document.getElementById('brand-logo');

        let joystickVector = { x: 0, y: 0 }; 
        let joystickTouchId = null; 
        
        let lookTouchId = null;
        let lastLookX = 0; let lastLookY = 0;
        let lastTapTime = 0; let lastTapPos = { x: 0, y: 0 };
        let targetRotationY = 0; let targetRotationX = 0;

        const DEFAULT_FOV = 70;
        let targetFOV = DEFAULT_FOV; 
        let pinchStartDist = 0; 
        let pinchStartFOV = DEFAULT_FOV;
        let isZooming = false; 
        let isZoomCooldown = false;

        init();
        animate();
        startClock();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            camera = new THREE.PerspectiveCamera(DEFAULT_FOV, window.innerWidth / window.innerHeight, 0.1, 100);
            
            if (window.innerWidth < window.innerHeight) { camera.position.copy(MOBILE_CAM_POS); } 
            else { camera.position.copy(DESKTOP_CAM_POS); }
            camera.lookAt(targetPosition.x, targetPosition.y + 1.5, targetPosition.z);
            camera.rotation.order = 'YXZ'; 
            
            targetRotationY = camera.rotation.y;
            targetRotationX = camera.rotation.x;

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0xeeeeee, 1.2); hemiLight.position.set(0, 20, 0); scene.add(hemiLight);
            
            const keyLight = new THREE.DirectionalLight(0xffffff, 3.5); 
            keyLight.position.set(0, 15, 0); 
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.set(2048, 2048); 
            keyLight.shadow.bias = -0.0001; 
            keyLight.shadow.radius = 60; 
            const d = 15; keyLight.shadow.camera.left = -d; keyLight.shadow.camera.right = d; keyLight.shadow.camera.top = d; keyLight.shadow.camera.bottom = -d; 
            scene.add(keyLight);
            
            const fillLight = new THREE.DirectionalLight(0xffeedd, 1.5); fillLight.position.set(-8, 5, 8); scene.add(fillLight);
            const topLight = new THREE.DirectionalLight(0xffffff, 0.8); topLight.position.set(0, 10, -6); scene.add(topLight);

            const pmremGenerator = new THREE.PMREMGenerator( new THREE.WebGLRenderer() );
            pmremGenerator.compileEquirectangularShader();
            scene.environment = pmremGenerator.fromScene(new THREE.Scene()).texture;

            const planeGeometry = new THREE.PlaneGeometry(200, 200);
            const shadowMaterial = new THREE.ShadowMaterial({ color: 0x000000, opacity: 0.2 });
            const floor = new THREE.Mesh(planeGeometry, shadowMaterial);
            floor.rotation.x = -Math.PI / 2; floor.position.y = 0; floor.receiveShadow = true; scene.add(floor);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace; 
            renderer.shadowMap.enabled = true; 
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.5;
            document.body.appendChild(renderer.domElement);

            controls = new PointerLockControls(camera, document.body);
            
            setupControlsEvents(); setupKeyControls(); setupTouchControls(); setupDoubleClickReset(); 
            setupZoomControls(); 
            
            window.addEventListener('resize', onWindowResize);

            // === 修改：缩短超时时间至 3秒 ===
            // 如果3秒内没连上数据库，直接加载默认模型，保证中国大陆用户能打开
            setTimeout(() => {
                if (!isModelLoaded) {
                    console.warn("Connection timeout (GFW?). Forcing default model.");
                    loadDefaultSculpture();
                }
            }, 3000);

            if(db) checkPinAndLoad(); 
            else loadDefaultSculpture();
        }

        function startClock() {
            function update() {
                const now = new Date();
                const y = now.getUTCFullYear();
                const m = String(now.getUTCMonth() + 1).padStart(2, '0');
                const d = String(now.getUTCDate()).padStart(2, '0');
                const h = String(now.getUTCHours()).padStart(2, '0');
                const min = String(now.getUTCMinutes()).padStart(2, '0');
                const s = String(now.getUTCSeconds()).padStart(2, '0');
                clockDiv.innerText = `${y}-${m}-${d} ${h}:${min}:${s} GMT`;
            }
            update();
            setInterval(update, 1000);
        }

        function mulberry32(a) {
            return function() {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        function getDailyModelID(models) {
            if (!models || models.length === 0) return null;
            const sortedModels = [...models].sort((a, b) => {
                const timeDiff = a.uploadDate.seconds - b.uploadDate.seconds;
                if (timeDiff !== 0) return timeDiff;
                return a.id.localeCompare(b.id);
            });
            const now = new Date();
            const daysSinceEpoch = Math.floor(now.getTime() / (1000 * 60 * 60 * 24));
            const cycle = Math.floor(daysSinceEpoch / sortedModels.length);
            const rng = mulberry32(cycle);
            const shuffled = [...sortedModels];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            const dailyIndex = daysSinceEpoch % sortedModels.length;
            return shuffled[dailyIndex].id;
        }

        async function checkPinAndLoad() {
            try {
                const pinQuery = query(collection(db, "model_library"), where("pinned", "==", true));
                const pinSnapshot = await getDocs(pinQuery);
                if (!pinSnapshot.empty) {
                    const pinDoc = pinSnapshot.docs[0].data();
                    loadModelFromUrl(pinDoc.url, pinDoc.name);
                    return;
                }
                const q = query(collection(db, "model_library"), where("active", "==", true));
                const querySnapshot = await getDocs(q);
                let models = [];
                querySnapshot.forEach((doc) => { models.push({ id: doc.id, ...doc.data() }); });
                if (models.length === 0) { loadDefaultSculpture(); return; }
                const dailyId = getDailyModelID(models);
                const selected = models.find(m => m.id === dailyId) || models[0];
                loadModelFromUrl(selected.url, selected.name);
            } catch (error) { 
                console.error("Firebase error", error); 
                // 出错立即加载默认，不要干等
                loadDefaultSculpture(); 
            }
        }

        function loadModelFromUrl(url, name) {
            const loader = new GLTFLoader();
            const dracoLoader = new DRACOLoader();
            // === 修改：使用 jsdelivr 加载 Draco，绕过 gstatic ===
            dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/draco/');
            loader.setDRACOLoader(dracoLoader);
            loader.load(url, (gltf) => {
                processAndPlaceModel(gltf.scene, name);
                revealScene();
            }, undefined, (err) => { 
                console.error("Load error, fallback", err);
                loadDefaultSculpture(); 
            });
        }

        function loadDefaultSculpture() {
            if (isModelLoaded) return; 
            const group = new THREE.Group();
            const material = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.2, metalness: 0.8 });
            const geo = new THREE.TorusKnotGeometry(0.8, 0.25, 128, 64);
            const mesh = new THREE.Mesh(geo, material); mesh.castShadow = true; mesh.receiveShadow = true; group.add(mesh);
            processAndPlaceModel(group, "Default Sculpture");
            revealScene();
        }

        function generateSystematicName(seed) {
            let hash = 0;
            if (!seed || seed.length === 0) return "NULL · 000 · Ø";
            for (let i = 0; i < seed.length; i++) { hash = ((hash << 5) - hash) + seed.charCodeAt(i); hash |= 0; }
            hash = Math.abs(hash);
            const rng = (s) => {
                let t = s + 0x6D2B79F5;
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            }
            const rand = rng(hash);
            let prefix = "";
            const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            for (let i = 0; i < 4; i++) {
                const charIndex = Math.floor(rng(hash + i) * letters.length);
                prefix += letters.charAt(charIndex);
            }
            const num = Math.floor(rng(hash + 99) * 1000).toString().padStart(3, '0'); 
            const symbols = ["α", "β", "γ", "δ", "ε", "ζ", "η", "θ", "ι", "κ", "λ", "μ", "Σ", "Ω", "Ø", "Δ"];
            const sIndex = Math.floor(rng(hash + 77) * symbols.length);
            return `${prefix} · ${num} · ${symbols[sIndex]}`;
        }

        function createMuseumLabel(modelName, sizeInfo) {
            if (labelMesh) { scene.remove(labelMesh); labelMesh = null; }
            const systematicName = generateSystematicName(modelName);
            const mockYear = Math.floor(Math.random() * (2025 - 2000 + 1)) + 2000;
            const materials = ["Bronze, Patina", "Polished Steel", "Marble", "Digital Polymer", "Mixed Media", "Resin", "Ceramic"];
            const randMat = materials[Math.floor(Math.random() * materials.length)];

            const canvas = document.createElement('canvas');
            canvas.width = 2048; canvas.height = 2048; 
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#f9f9f9'; ctx.fillRect(0, 0, 2048, 2048);
            ctx.textAlign = 'left';
            
            ctx.font = 'bold 64px Helvetica, Arial'; 
            ctx.fillStyle = '#000000'; 
            ctx.fillText("EXHIBITION OF THE DAY", 100, 140);

            ctx.font = 'bold 176px Helvetica, Arial'; 
            ctx.fillStyle = '#000000'; 
            ctx.fillText(systematicName, 100, 450);

            ctx.font = 'bold 100px Helvetica, Arial'; 
            ctx.fillStyle = '#000000'; 
            
            ctx.fillText(mockYear, 100, 750);
            ctx.fillText(randMat, 100, 950);
            ctx.fillText(sizeInfo, 100, 1150);
            
            ctx.font = 'bold 64px Helvetica, Arial'; 
            ctx.fillStyle = '#000000'; 
            ctx.fillText("Courtesy of the Digital Archive", 100, 1850);

            ctx.strokeStyle = '#aaaaaa'; ctx.lineWidth = 40; ctx.strokeRect(0, 0, 2048, 2048);

            const texture = new THREE.CanvasTexture(canvas);
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            
            const labelGeo = new THREE.BoxGeometry(0.4, 0.02, 0.4); 
            const labelMat = new THREE.MeshStandardMaterial({ map: texture, color: 0xffffff, roughness: 1.0, metalness: 0.0 });
            const mesh = new THREE.Mesh(labelGeo, labelMat);
            mesh.castShadow = true; mesh.receiveShadow = true;
            return mesh;
        }

        function getSolidHeight(model, boxHeight) {
            const yCoords = [];
            model.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    const pos = child.geometry.attributes.position;
                    const v = new THREE.Vector3();
                    for (let i = 0; i < pos.count; i += 5) {
                        v.fromBufferAttribute(pos, i);
                        v.applyMatrix4(child.matrix);
                        yCoords.push(v.y);
                    }
                }
            });
            if (yCoords.length === 0) return boxHeight; 
            yCoords.sort((a, b) => a - b);
            const trimStart = Math.floor(yCoords.length * 0.02); 
            const trimEnd = Math.floor(yCoords.length * 0.98);
            const minY = yCoords[trimStart] || yCoords[0];
            const maxY = yCoords[trimEnd] || yCoords[yCoords.length - 1];
            let solidH = maxY - minY;
            if (solidH < boxHeight * 0.2) return boxHeight;
            return solidH;
        }

        function processAndPlaceModel(rawModel, rawName) {
            if (sculptureWrapper) scene.remove(sculptureWrapper);
            if (labelMesh) scene.remove(labelMesh);
            rawModel.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true; child.receiveShadow = true;
                    if (child.material && child.material.color) {
                         if(child.material.color.r < 0.1 && child.material.color.g < 0.1 && child.material.color.b < 0.1) child.material.color.setHex(0xaaaaaa);
                         child.material.needsUpdate = true;
                    }
                }
            });
            rawModel.position.set(0,0,0); rawModel.scale.set(1,1,1); rawModel.rotation.set(0,0,0); rawModel.updateMatrixWorld(true);
            const initialBox = new THREE.Box3().setFromObject(rawModel);
            const initialSize = initialBox.getSize(new THREE.Vector3());
            const solidHeight = getSolidHeight(rawModel, initialSize.y);
            const targetHeight = 3.5;
            const scaleFactor = targetHeight / solidHeight;
            rawModel.scale.setScalar(scaleFactor); rawModel.updateMatrixWorld(true);
            const newBox = new THREE.Box3().setFromObject(rawModel);
            const newCenter = newBox.getCenter(new THREE.Vector3());
            const finalSize = newBox.getSize(new THREE.Vector3());
            sculptureWrapper = new THREE.Group(); scene.add(sculptureWrapper);
            rawModel.position.x = -newCenter.x; rawModel.position.z = -newCenter.z; 
            rawModel.position.y = -newBox.min.y; 
            sculptureWrapper.add(rawModel);
            sculptureWrapper.position.copy(targetPosition); sculptureWrapper.rotation.y = 0; 
            forceGrounding(sculptureWrapper);
            const formattedSize = `${(finalSize.x).toFixed(1)}m x ${(finalSize.y).toFixed(1)}m x ${(finalSize.z).toFixed(1)}m`;
            labelMesh = createMuseumLabel(rawName || "Untitled", formattedSize);
            const wrapperZ = targetPosition.z; const labelZ = wrapperZ + (finalSize.z / 2) + 2.5; 
            labelMesh.position.set(0, 0.01, labelZ); labelMesh.rotation.x = 0; scene.add(labelMesh);
            colliderRadius = Math.max(finalSize.x, finalSize.z) / 2 + 0.1; 
            isModelLoaded = true;
        }

        function forceGrounding(wrapper) {
            let minY = Infinity; wrapper.updateMatrixWorld(true);
            wrapper.traverse((child) => { if (child.isMesh && child.geometry) { const pos = child.geometry.attributes.position; const v = new THREE.Vector3(); for (let i = 0; i < pos.count; i+=3) { v.fromBufferAttribute(pos, i); v.applyMatrix4(child.matrixWorld); if (v.y < minY) minY = v.y; } } });
            if (minY !== Infinity && Math.abs(minY) > 0.001) { wrapper.position.y -= minY; }
        }

        function revealScene() {
            setTimeout(() => {
                gsap.to(introOverlayDiv, { opacity: 0, duration: 2.0, ease: "power2.inOut", 
                    onComplete: () => { 
                        introOverlayDiv.style.display = 'none'; 
                        clickCaptureDiv.style.display = 'block'; 
                        instructionText.style.opacity = '1';
                        clockDiv.style.opacity = '1'; 
                        brandLogo.style.opacity = '1';
                        resetMovementState();
                        isIntroFinished = true; 
                    }
                });
            }, 100);
        }

        function resetMovementState() {
            moveForward = false; moveBackward = false; moveLeft = false; moveRight = false;
            joystickVector = { x: 0, y: 0 };
            velocity.set(0, 0, 0);
        }

        function resetCamera(duration = 1.5, ease = "power2.inOut") {
             if (!isModelLoaded || !isIntroFinished || isResetting) return;
             isResetting = true; 
             const destPos = (window.innerWidth < window.innerHeight) ? MOBILE_CAM_POS : DESKTOP_CAM_POS;
             const tl = gsap.timeline({
                 onUpdate: () => {
                     targetRotationY = camera.rotation.y;
                     targetRotationX = camera.rotation.x;
                     targetFOV = DEFAULT_FOV; 
                 },
                 onComplete: () => { 
                     isResetting = false; 
                     resetMovementState(); 
                 }
             });
             tl.to(camera.position, { x: destPos.x, y: destPos.y, z: destPos.z, duration: duration, ease: ease }, 0);
             const tempCam = camera.clone();
             tempCam.position.copy(destPos);
             tempCam.lookAt(targetPosition.x, targetPosition.y + 1.5, targetPosition.z);
             tl.to(camera.quaternion, { x: tempCam.quaternion.x, y: tempCam.quaternion.y, z: tempCam.quaternion.z, w: tempCam.quaternion.w, duration: duration, ease: ease }, 0);
             tl.to(camera, { fov: DEFAULT_FOV, duration: duration, ease: ease }, 0); 
        }

        function setupDoubleClickReset() {
            window.addEventListener('dblclick', () => { resetCamera(0.15, "expo.out"); });
            document.addEventListener('touchstart', (e) => {
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTapTime;
                const touch = e.changedTouches[0];
                const dist = Math.sqrt(Math.pow(touch.clientX - lastTapPos.x, 2) + Math.pow(touch.clientY - lastTapPos.y, 2));
                if (tapLength < 250 && tapLength > 0 && dist < 30) { e.preventDefault(); resetCamera(0.5, "power2.inOut"); } 
                else { lastTapPos = { x: touch.clientX, y: touch.clientY }; lastTapTime = currentTime; }
            }, { passive: false });
        }

        function setupZoomControls() {
            document.addEventListener('wheel', (e) => {
                if (!isIntroFinished || isResetting) return;
                const sensitivity = 0.05;
                targetFOV += e.deltaY * sensitivity;
                targetFOV = THREE.MathUtils.clamp(targetFOV, 10, 90);
            }, { passive: true });

            document.addEventListener('touchstart', (e) => {
                if (joystickTouchId !== null) return;
                if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    pinchStartDist = Math.sqrt(dx*dx + dy*dy);
                    pinchStartFOV = targetFOV; 
                    isZooming = true; 
                }
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2 && isIntroFinished && !isResetting && isZooming) {
                    e.preventDefault(); 
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const deltaDist = dist - pinchStartDist;
                    targetFOV = pinchStartFOV - (deltaDist * 0.15);
                    targetFOV = THREE.MathUtils.clamp(targetFOV, 10, 90);
                }
            }, { passive: false });

            document.addEventListener('touchend', (e) => {
                if (e.touches.length < 2) {
                    if (isZooming) {
                        isZooming = false;
                        isZoomCooldown = true;
                        lookTouchId = null; 
                        setTimeout(() => { isZoomCooldown = false; }, 200); 
                        targetFOV = DEFAULT_FOV; 
                    }
                }
            });
        }

        function setupTouchControls() {
            const joystickZone = document.getElementById('joystick-zone');
            const joystickKnob = document.getElementById('joystick-knob');
            const zoneRect = joystickZone.getBoundingClientRect();
            const center = { x: zoneRect.width / 2, y: zoneRect.height / 2 };
            const maxRadius = (zoneRect.width / 2) - 20;
            
            joystickZone.addEventListener('touchstart', (e) => {
                if (!isIntroFinished) return; 
                e.preventDefault();
                const touch = e.changedTouches[0];
                joystickTouchId = touch.identifier;
                joystickZone.classList.add('joystick-active');
                updateJoystick(touch);
            }, {passive: false});

            joystickZone.addEventListener('touchmove', (e) => {
                if (!isIntroFinished) return;
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystickTouchId) {
                        updateJoystick(e.changedTouches[i]);
                        break;
                    }
                }
            }, {passive: false});

            const endJoystick = (e) => {
                 for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystickTouchId) {
                        joystickTouchId = null;
                        joystickVector = { x: 0, y: 0 };
                        joystickZone.classList.remove('joystick-active');
                        gsap.to(joystickKnob, { left: '50%', top: '50%', duration: 0.2 });
                        break;
                    }
                }
            };
            joystickZone.addEventListener('touchend', endJoystick);
            joystickZone.addEventListener('touchcancel', endJoystick);

            function updateJoystick(touch) {
                const rect = joystickZone.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                let dx = x - center.x; let dy = y - center.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                if (distance > maxRadius) { const angle = Math.atan2(dy, dx); dx = Math.cos(angle) * maxRadius; dy = Math.sin(angle) * maxRadius; }
                joystickKnob.style.left = (center.x + dx) + 'px'; joystickKnob.style.top = (center.y + dy) + 'px';
                joystickVector.x = dx / maxRadius; joystickVector.y = dy / maxRadius; 
            }

            document.addEventListener('touchstart', (e) => {
                if (!isIntroFinished) return; 
                if (e.target.closest('#joystick-zone')) return;
                const touch = e.changedTouches[0];
                if (touch.identifier !== joystickTouchId) {
                    lookTouchId = touch.identifier;
                    lastLookX = touch.clientX; lastLookY = touch.clientY;
                }
            }, {passive: false});

            document.addEventListener('touchmove', (e) => {
                if (!isIntroFinished) return;
                if (isZooming || isZoomCooldown) return; 

                let touch = null;
                for(let i=0; i<e.changedTouches.length; i++) { if(e.changedTouches[i].identifier === lookTouchId) { touch = e.changedTouches[i]; break; } }
                if (!touch) return;
                const deltaX = touch.clientX - lastLookX; const deltaY = touch.clientY - lastLookY;
                lastLookX = touch.clientX; lastLookY = touch.clientY;
                const sensitivity = 0.01; 
                targetRotationY -= deltaX * sensitivity;
                targetRotationX -= deltaY * sensitivity;
                targetRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetRotationX));
            }, {passive: false});

            document.addEventListener('touchend', (e) => { for(let i=0; i<e.changedTouches.length; i++) { if(e.changedTouches[i].identifier === lookTouchId) { lookTouchId = null; break; } } });
        }

        function setupControlsEvents() { 
            controls.addEventListener('lock', () => { clickCaptureDiv.style.display = 'none'; instructionText.style.opacity = '0'; }); 
            controls.addEventListener('unlock', () => { if (isModelLoaded) { clickCaptureDiv.style.display = 'block'; instructionText.style.opacity = '1'; } }); 
            if (!('ontouchstart' in window)) { clickCaptureDiv.addEventListener('click', () => { if(isIntroFinished) controls.lock(); }); } else { clickCaptureDiv.style.display = 'none'; }
        }
        
        function setupKeyControls() { const onKeyDown = (e) => { if(!isIntroFinished) return; switch (e.code) { case 'ArrowUp': case 'KeyW': moveForward = true; break; case 'ArrowLeft': case 'KeyA': moveLeft = true; break; case 'ArrowDown': case 'KeyS': moveBackward = true; break; case 'ArrowRight': case 'KeyD': moveRight = true; break; } }; const onKeyUp = (e) => { switch (e.code) { case 'ArrowUp': case 'KeyW': moveForward = false; break; case 'ArrowLeft': case 'KeyA': moveLeft = false; break; case 'ArrowDown': case 'KeyS': moveBackward = false; break; case 'ArrowRight': case 'KeyD': moveRight = false; break; } }; document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp); }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function checkCollision() { if (!sculptureWrapper) return; const playerPos = new THREE.Vector2(camera.position.x, camera.position.z); const objectPos = new THREE.Vector2(sculptureWrapper.position.x, sculptureWrapper.position.z); const distance = playerPos.distanceTo(objectPos); if (distance < colliderRadius) { const pushDir = playerPos.sub(objectPos).normalize(); const newPos = objectPos.add(pushDir.multiplyScalar(colliderRadius)); camera.position.x = newPos.x; camera.position.z = newPos.y; } }
        
        function animate() { 
            requestAnimationFrame(animate); 
            const time = performance.now(); 
            let delta = (time - prevTime) / 1000;
            if (delta > 0.05) delta = 0.05; 

            velocity.x -= velocity.x * 10.0 * delta; 
            velocity.z -= velocity.z * 10.0 * delta; 
            
            if(Math.abs(velocity.x) < 0.001) velocity.x = 0;
            if(Math.abs(velocity.z) < 0.001) velocity.z = 0;

            direction.z = Number(moveForward) - Number(moveBackward); 
            direction.x = Number(moveRight) - Number(moveLeft); 
            direction.normalize(); 
            
            if (isIntroFinished) { 
                if (moveForward || moveBackward) velocity.z -= direction.z * 80.0 * delta; if (moveLeft || moveRight) velocity.x -= direction.x * 80.0 * delta; 
                
                if (!isZooming && (joystickVector.x !== 0 || joystickVector.y !== 0)) { velocity.z -= -joystickVector.y * 80.0 * delta; velocity.x -= joystickVector.x * 80.0 * delta; }
                
                if (controls.isLocked) { 
                    controls.moveRight(-velocity.x * delta); controls.moveForward(-velocity.z * delta); 
                    targetRotationY = camera.rotation.y;
                    targetRotationX = camera.rotation.x;
                } else { 
                    const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir); camDir.y = 0; camDir.normalize(); 
                    const camRight = new THREE.Vector3(); camRight.crossVectors(camDir, new THREE.Vector3(0, 1, 0)).normalize(); 
                    camera.position.addScaledVector(camDir, -velocity.z * delta); camera.position.addScaledVector(camRight, -velocity.x * delta);
                    if (!isResetting) {
                        camera.rotation.y += (targetRotationY - camera.rotation.y) * 0.1;
                        camera.rotation.x += (targetRotationX - camera.rotation.x) * 0.1;
                    }
                }
                checkCollision(); 
            }
            
            if (camera.fov !== targetFOV) {
                camera.fov += (targetFOV - camera.fov) * 0.2; 
                camera.updateProjectionMatrix();
            }

            prevTime = time; 
            renderer.render(scene, camera); 
        }
    </script>
</body>
</html>